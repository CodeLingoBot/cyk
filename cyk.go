package cyk

import (
	"errors"
	"fmt"
	"strings"
)

//Grammar is present the CFG grammars
//ex:  S-> AB
//     LeftSymbol: S
//     RightSymbol[0]: A, RightSymbol[1]: B
//     RightSymbol could be terminal or variables
type Grammar struct {
	LeftSymbol  string
	RightSymbol []string
}

//We use matrix to store our CYK result and maniplate it
//ex: X_11 -> A ==> map[MatrixIndicator{ X_axi: 1, Y_axi: 1}] = []string{"A"}
type MatrixIndicator struct {
	X_axi int
	Y_axi int
}

//Using map to handle matrix result
type MatrixResult map[MatrixIndicator][]string

type CYK struct {
	Grammars    []Grammar
	CYKResult   MatrixResult
	InputString string
	StartSymbol string
}

func NewCYK(startSymbol string) *CYK {
	newCYK := &CYK{StartSymbol: startSymbol}
	newCYK.CYKResult = make(map[MatrixIndicator][]string)
	return newCYK
}

// Find terminal assign variable
// ex: A->a  using `a` find A
func (c *CYK) findTerminalAssign(terminal string) []string {
	var retList []string
	for _, targetG := range c.Grammars {
		for _, rSymbol := range targetG.RightSymbol {
			if rSymbol == terminal {
				retList = append(retList, targetG.LeftSymbol)
			}
		}
	}

	return retList
}

func testEq(a, b []string) bool {

	if a == nil && b == nil {
		return true
	}

	if a == nil || b == nil {
		return false
	}

	if len(a) != len(b) {
		return false
	}

	for i := range a {
		if a[i] != b[i] {
			return false
		}
	}

	return true
}

func (c *CYK) findVariableAssign(symbol []string) string {
	for _, targetG := range c.Grammars {
		//fmt.Println(" grammarR=", targetG.RightSymbol, " symbol=", symbol)
		if testEq(symbol, targetG.RightSymbol) {
			return targetG.LeftSymbol
		}
	}

	return ""
}

//To eval if string is terminal not variable
func (c *CYK) isTerminal(testString string) bool {
	return testString == strings.ToLower(testString)
}

//Insert grammar in this CYK
// Ex: S->{AB}  InputGrammar("S", "A", "B")
// Please note: Uppercase is variable, Lowercase is terminal
func (c *CYK) InputGrammar(leftSymbol string, rightSymbols ...string) {
	newGrammar := Grammar{LeftSymbol: leftSymbol, RightSymbol: rightSymbols}
	c.Grammars = append(c.Grammars, newGrammar)
}

// Take input to run CYK algorithm and eval if this input can be generated by this CFG
func (c *CYK) Eval(input string) bool {
	c.runCYK(input)
	return c.evalCYKResult()
}

func (c *CYK) getResultMatrix(x, y int) ([]string, error) {
	val, ok := c.CYKResult[MatrixIndicator{X_axi: x, Y_axi: y}]
	if ok {
		return val, nil
	} else {
		fmt.Println("index x=", x, " y=", y, " is not exist!.")
		return nil, errors.New("Not exist!")
	}
}

func (c *CYK) setResultMatrix(x, y int, val []string) {
	c.CYKResult[MatrixIndicator{X_axi: x, Y_axi: y}] = val
}

// Run CYK algorithm
func (c *CYK) runCYK(input string) {
	c.InputString = input
	//Start to calculate X_11, X_22, X_33
	for i := 0; i < len(input); i++ {
		//string is zero-base
		variable := c.findTerminalAssign(string(input[i]))
		//Matrix indicator is 1-base
		c.setResultMatrix(i, i, variable)
	}

	//start triangle calculate
	for loop := 1; loop <= len(c.InputString); loop++ {
		for i := 0; i < len(c.InputString)-loop; i++ {
			j := i + loop
			variables, err := c.getResultMatrix(i, i+loop-1)
			if err != nil {
				fmt.Println("error on i=", i, " j=", j)
				return
			}
			firstV := variables[0]
			secondVal, _ := c.getResultMatrix(j, j)
			var retStr1 []string
			var retStr2 []string
			retStr1 = append(retStr1, firstV)
			retStr1 = append(retStr1, secondVal[1])
			retStr2 = append(retStr2, firstV)
			retStr2 = append(retStr2, secondVal[0])

			var result []string
			leftFirst := c.findVariableAssign(retStr1)
			if leftFirst != "" {
				result = append(result, leftFirst)
			}

			leftSec := c.findVariableAssign(retStr2)
			if leftSec != "" {
				result = append(result, leftSec)
			}
			c.setResultMatrix(i, j, result)
		}
	}
}

// Eval CYK result and make sure latest CYK Result only contain variable not assign to terminal
// ex: latest result is "S" which S->AB
func (c *CYK) evalCYKResult() bool {
	finalResult, err := c.getResultMatrix(0, len(c.InputString)-1)
	if err != nil {
		return false
	}
	return len(finalResult) == 1 && finalResult[0] == c.StartSymbol
}

// Print out the triangle result on CYK
func (c *CYK) PrintResult() {

	if len(c.CYKResult) == 0 {
		fmt.Println("We still not calculate CYK or no result...")
		return
	}

	fmt.Printf("1:")
	for i := 0; i < len(c.InputString); i++ {
		c.printResultMatrixElement(i, i)
	}
	fmt.Printf("\n")

	lineIndex := 2
	for loop := 1; loop < len(c.InputString); loop++ {

		fmt.Printf("%d:", lineIndex)
		for i := 0; i < len(c.InputString)-loop; i++ {
			j := i + loop
			c.printResultMatrixElement(i, j)
		}
		fmt.Printf("\n")
		lineIndex = lineIndex + 1
	}
}

func (c *CYK) printResultMatrixElement(i, j int) {
	fmt.Printf("\tX%d%d:{", i+1, j+1)

	results, err := c.getResultMatrix(i, j)
	if err != nil {
		fmt.Println("Empty result")
		return
	}
	for _, str := range results {
		fmt.Printf("%s,", str)
	}
	fmt.Printf("}")
}
