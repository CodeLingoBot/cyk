package cyk

import (
	"fmt"
	"strings"
)

//Grammar is present the CFG grammars
//ex:  S-> AB
//     LeftSymbol: S
//     RightSymbol[0]: A, RightSymbol[1]: B
//     RightSymbol could be terminal or variables
type Grammar struct {
	LeftSymbol  string
	RightSymbol []string
}

//We use matrix to store our CYK result and maniplate it
//ex: X_11 -> A ==> map[MatrixIndicator{ X_axi: 1, Y_axi: 1}] = []string{"A"}
type MatrixIndicator struct {
	X_axi int
	Y_axi int
}

//Using map to handle matrix result
type MatrixResult map[MatrixIndicator][]string

type CYK struct {
	Grammars   []Grammar
	CYKResult  MatrixResult
	EvalString string
}

func NewCYK() *CYK {
	newCYK := &CYK{}
	newCYK.CYKResult = make(map[MatrixIndicator][]string)
	return newCYK
}

// Find terminal assign variable
// ex: A->a  using `a` find A
func (c *CYK) terminalAssign(terminal string) []string {
	var retList []string
	for _, targetG := range c.Grammars {
		for _, rSymbol := range targetG.RightSymbol {
			if rSymbol == terminal {
				retList = append(retList, targetG.LeftSymbol)
			}
		}
	}

	return retList
}

//To eval if string is terminal not variable
func (c *CYK) isTerminal(testString string) bool {
	return testString == strings.ToLower(testString)
}

//Insert grammar in this CYK
// Ex: S->{AB}  InputGrammar("S", "A", "B")
// Please note: Uppercase is variable, Lowercase is terminal
func (c *CYK) InputGrammar(leftSymbol string, rightSymbols ...string) {
	newGrammar := Grammar{LeftSymbol: leftSymbol, RightSymbol: rightSymbols}
	c.Grammars = append(c.Grammars, newGrammar)
}

// Take input to run CYK algorithm and eval if this input can be generated by this CFG
func (c *CYK) Eval(input string) bool {
	c.runCYK(input)
	return c.evalCYKResult()
}

// Run CYK algorithm
func (c *CYK) runCYK(input string) {
	c.EvalString = input
	//Start to calculate X_11, X_22, X_33
	for i := 0; i < len(input); i++ {
		//string is zero-base
		variable := c.terminalAssign(string(input[i]))
		//Matrix indicator is 1-base
		c.CYKResult[MatrixIndicator{X_axi: i + 1, Y_axi: i + 1}] = variable
	}

	//for i in
}

// Eval CYK result and make sure latest CYK Result only contain variable not assign to terminal
// ex: latest result is "S" which S->AB
func (c *CYK) evalCYKResult() bool {
	return false
}

func (c *CYK) PrintResult() {

	if len(c.CYKResult) == 0 {
		fmt.Println("We still not calculate CYK or no result...")
		return
	}

	fmt.Printf("1:")
	for i := 1; i <= len(c.EvalString); i++ {
		fmt.Printf("\tX%d%d:{", i, i)
		results := c.CYKResult[MatrixIndicator{X_axi: i, Y_axi: i}]
		for _, str := range results {
			fmt.Printf("%s,", str)
		}
		fmt.Printf("}")
	}
	fmt.Printf("\n")
}
