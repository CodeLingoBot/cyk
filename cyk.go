package cyk

import (
	"strings"
)

//Grammar is present the CFG grammars
//ex:  S-> AB
//     LeftSymbol: S
//     RightSymbol[0]: A, RightSymbol[1]: B
//     RightSymbol could be terminal or variables
type Grammar struct {
	LeftSymbol  string
	RightSymbol []string
}

//We use matrix to store our CYK result and maniplate it
//ex: X_11 -> A ==> map[MatrixIndicator{ X_axi: 1, Y_axi: 1}] = []string{"A"}
type MatrixIndicator struct {
	X_axi int
	Y_axi int
}

//Using map to handle matrix result
type MatrixResult map[MatrixIndicator][]string

type CYK struct {
	Grammars   []Grammar
	CYKResult  MatrixResult
	EvalString string
}

func NewCYK() *CYK {
	newCYK := &CYK{}
	newCYK.CYKResult = make(map[MatrixIndicator][]string)
	return newCYK
}

// Find terminal assign variable
// ex: A->a  using `a` find A
func (c *CYK) terminalAssign(terminal string) string {
	for _, targetG := range c.Grammars {
		for _, rSymbol := range targetG.RightSymbol {
			if rSymbol == terminal {
				return targetG.LeftSymbol
			}
		}
	}

	return ""
}

//To eval if string is terminal not variable
func (c *CYK) isTerminal(testString string) bool {
	return testString == strings.ToLower(testString)
}

//Insert grammar in this CYK
// Ex: S->{AB}  InputGrammar("S", "A", "B")
// Please note: Uppercase is variable, Lowercase is terminal
func (c *CYK) InputGrammar(leftSymbol string, rightSymbols ...string) {
	newGrammar := Grammar{LeftSymbol: leftSymbol, RightSymbol: rightSymbols}
	c.Grammars = append(c.Grammars, newGrammar)
}

// Take input to run CYK algorithm and eval if this input can be generated by this CFG
func (c *CYK) Eval(input string) bool {
	return false
}

// Run CYK algorithm
func (c *CYK) runCYK() {
}

// Eval CYK result and make sure latest CYK Result only contain variable not assign to terminal
// ex: latest result is "S" which S->AB
func (c *CYK) evalCYKResult() bool {
	return false
}
